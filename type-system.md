# 类型系统概念地图

> **目标**：构建类型系统的完整心理模型，理解概念之间的依赖关系和层次结构

## 📊 学习路径图

```
第 1 层：基础层 → 第 2 层：关系层 → 第 3 层：构造层 → 第 4 层：型变层 → 第 5 层：推导层 → 第 6 层：高级层
   ↓              ↓              ↓              ↓              ↓              ↓
 理解"类型"    理解"大小"    创造新类型    泛型的关系    自动推断      复杂特性
```

---

## 第 1 层：基础层 - 类型的本质

> **核心问题**：什么是类型？类型、值、类型构造器的关系？

### [x] **类型（Type）**
- **定义**：值的集合 + 允许的操作
- **本质**：一种分类系统，把所有可能的值分成不同的组
- **例子**：`int` = 所有整数 + {+, -, *, /, ...}
- 依赖：无
- 后续：所有概念的基础

### [x] **值（Value）**
- **定义**：程序中的具体数据
- **关系**：每个值属于某个类型
- **例子**：`42` 是一个值，它的类型是 `int`
- 依赖：无
- 后续：类型是值的抽象

### [x] **类型构造器（Type Constructor）**
- **定义**：接受类型参数，构造新类型的"工具"
- **本质**：类型级别的函数
- **例子**：`list` 接受 `int`，返回 `list[int]`
- **元数**：接受的类型参数个数（`list` 是一元，`dict` 是二元）
- 依赖：类型
- 后续：泛型、高阶类型

### [x] **类型注解 vs 运行时类型**
- **静态类型**：代码中的类型提示，用于类型检查器
- **动态类型**：运行时实际的类型，Python 用 `type()` 查看
- **关键区别**：Python 的类型提示不影响运行时行为
- 依赖：类型
- 后续：类型安全、渐进类型

---

## 第 2 层：关系层 - 类型之间的大小关系

> **核心问题**：类型之间如何比较？什么是"子类型"？

### [x] **子类型（Subtyping）**
- **定义**：`A <: B` 表示"A 是 B 的子类型"
- **替换原则**：A 的值可以安全地用在期望 B 的地方
- **例子**：`Dog <: Animal`（Dog 可以当 Animal 用）
- 依赖：类型
- 后续：型变、协变、逆变的基础

### [x] **子类型的三大规则**
- **自反性**：`A <: A`（任何类型是自己的子类型）
- **传递性**：`A <: B` 且 `B <: C` → `A <: C`
- **反对称性**：`A <: B` 且 `B <: A` → `A = B`（类型等价）
- 依赖：子类型
- 后续：型变推导

### [x] **类型等价（Type Equivalence）**
- **定义**：两个类型是否"相同"
- **名义等价**：按名字判断（Python 类继承）  Note:哇，这个太赞了，结构等价和名义等价，难怪。
- **结构等价**：按结构判断（Protocol）
- 依赖：类型
- 后续：结构化类型 vs 名义类型

### [x] **Top 类型和 Bottom 类型**
- **Top 类型**：所有类型的父类型（Python 中是 `object`，类型系统中是 `Any`）
- **Bottom 类型**：所有类型的子类型（Python 中是 `Never`）
- **用途**：类型层级的边界
- 依赖：子类型
- 后续：联合类型、交叉类型

---

## 第 3 层：构造层 - 如何创造新类型

> **核心问题**：如何表达"任意类型"？如何构造参数化的类型？

### [x] **类型变量（TypeVar）**
- **定义**：表示"待绑定的类型"的变量
- **本质**：泛型的基础工具，不是类型本身
- **作用域**：在函数签名内建立类型约束
- **例子**：`T = TypeVar('T')`，在调用时 `T` 被绑定到具体类型
- 依赖：类型
- 后续：泛型、型变

### [x] **约束类型变量（Constrained TypeVar）**
- **定义**：限制类型变量只能是列举的几个类型之一
- **语法**：`T = TypeVar('T', int, str)` → T 只能是 int 或 str
- **用途**：需要对多个具体类型统一处理时
- 依赖：TypeVar
- 后续：与 Union 的区别

### [x] **有界类型变量（Bounded TypeVar）**
- **定义**：限制类型变量必须是某个类型的子类型
- **语法**：`T = TypeVar('T', bound=Animal)` → T 必须 <: Animal
- **用途**：需要使用基类的方法/属性时
- 依赖：TypeVar、子类型
- 后续：上界、协变

### [x] **泛型（Generic）**
- **定义**：使用类型变量定义的类型或函数
- **本质**：参数化的类型（类型的模板）
- **例子**：`class Box(Generic[T])` 可以实例化为 `Box[int]`, `Box[str]`
- 依赖：TypeVar
- 后续：型变

### [x] **类型别名（Type Alias）**
- **定义**：给复杂类型起一个简短的名字
- **语法**：`Vector = list[float]` 或 `Vector: TypeAlias = list[float]`
- **用途**：提高代码可读性
- 依赖：类型
- 后续：NewType（区别）

### [x] **NewType**
- **定义**：创建一个"名义上不同"的类型（运行时等价）
- **语法**：`UserId = NewType('UserId', int)`
- **区别**：比类型别名更严格，`UserId` 和 `int` 在类型检查器看来是不同类型
- 依赖：类型
- 后续：名义类型

---

## 第 4 层：型变层 - 泛型类型的子类型关系

> **核心问题**：如果 `Dog <: Animal`，那么 `List[Dog]` 和 `List[Animal]` 是什么关系？

### [x] **型变（Variance）**
- **定义**：描述"类型参数的子类型关系"如何影响"构造类型的子类型关系"
- **核心问题**：`F[A] <: F[B]` 与 `A <: B` 的关系
- **三种型变**：协变、逆变、不变
- 依赖：子类型、泛型
- 后续：所有泛型类型的行为

### [x] **协变（Covariance）**
- **定义**：保持子类型方向 - `A <: B` → `F[A] <: F[B]`
- **直觉**：生产者/输出/只读
- **上界**：关注能"输出"什么类型的上限
- **例子**：`tuple[Dog, ...]` <: `tuple[Animal, ...]`（元组只读）
- **Python 语法**：`T_co = TypeVar('T_co', covariant=True)`
- 依赖：型变、子类型
- 后续：函数返回值

### [x] **逆变（Contravariance）**
- **定义**：反转子类型方向 - `A <: B` → `F[B] <: F[A]`
- **直觉**：消费者/输入/只写
- **下界**：关注能"接受"什么类型的下限
- **例子**：`Callable[[Animal], None]` <: `Callable[[Dog], None]`（函数参数）
- **Python 语法**：`T_contra = TypeVar('T_contra', contravariant=True)`
- 依赖：型变、子类型
- 后续：函数参数

### [x] **不变（Invariance）**
- **定义**：无子类型关系 - `A <: B` 时，`F[A]` 和 `F[B]` 无关系
- **直觉**：既能读又能写
- **例子**：`list[Dog]` 和 `list[Animal]` 无关系（列表可变）
- **Python 默认**：不指定 covariant/contravariant 时就是不变
- 依赖：型变、子类型
- 后续：大多数可变容器

### [x] **函数类型的型变**
- **规则**：参数逆变，返回值协变
- **公式**：`(T1 → S1) <: (T2 → S2)` ⟺ `T2 <: T1` 且 `S1 <: S2`
- **直觉**：函数能接受的越宽泛越好，返回的越具体越好
- 依赖：协变、逆变
- 后续：Callable、ParamSpec

### [x] **PECS 原则**
- **Producer Extends, Consumer Super**
- **Producer**：协变（输出），关注上界
- **Consumer**：逆变（输入），关注下界
- **记忆口诀**：生产协变，消费逆变
- 依赖：协变、逆变
- 后续：设计泛型类型的指导原则

---

## 第 5 层：推导层 - 自动推断类型

> **核心问题**：如何让类型检查器自动推断类型？

### [x] **类型推导（Type Inference）**
- **定义**：根据上下文自动推断变量/表达式的类型
- **例子**：`x = 5` → 推断 `x: int`
- **范围**：局部变量、函数返回值、泛型实例化
- 依赖：类型
- 后续：类型窄化

### [x] **类型窄化（Type Narrowing）**
- **定义**：根据控制流缩小类型范围
- **例子**：`isinstance(x, int)` 后，`x` 的类型从 `int | str` 窄化为 `int`
- **方法**：isinstance、is None、assert、match-case
- 依赖：类型推导
- 后续：TypeGuard、TypeIs

### [x] **类型守卫（TypeGuard）**
- **定义**：用户自定义的类型窄化函数
- **语法**：`def is_str(x: Any) -> TypeGuard[str]`
- **用途**：自定义类型检查逻辑
- 依赖：类型窄化
- 后续：TypeIs（更严格的版本）

### [x] **TypeIs**
- **定义**：比 TypeGuard 更严格的类型谓词（Python 3.13+）
- **区别**：TypeGuard 宽松，TypeIs 精确
- 依赖：TypeGuard
- 后续：类型窄化的高级用法

---

## 第 6 层：高级层 - 复杂类型特性

> **核心问题**：如何表达更复杂的类型约束？

### 6.1 组合类型

### [x] **联合类型（Union）**
- **定义**：表示"多个类型之一"
- **语法**：`int | str` 或 `Union[int, str]`
- **操作**：只能使用所有成员类型的**共同操作**
- 依赖：类型
- 后续：类型窄化

### [x] **可选类型（Optional）**
- **定义**：`Optional[T]` = `T | None`
- **用途**：表示"可能为 None"的值
- 依赖：联合类型
- 后续：类型窄化

### [ ] **交叉类型（Intersection）**
- **定义**：同时满足多个类型（Python 不直接支持）
- **Python 替代**：Protocol 的多重继承
- 依赖：类型
- 后续：Protocol

### 6.2 类型系统风格

### [ ] **名义类型（Nominal Typing）**
- **定义**：按类型的"名字"（声明的继承关系）判断
- **例子**：`class Dog(Animal)` → Dog 是 Animal 的子类型
- **特点**：必须显式声明关系
- 依赖：子类型
- 后续：Python 类继承

### [ ] **结构化类型（Structural Typing）**
- **定义**：按类型的"结构"（拥有的方法/属性）判断
- **例子**：只要有 `speak()` 方法，就是 `Speakable`
- **特点**：鸭子类型的静态版本
- 依赖：子类型
- 后续：Protocol

### [ ] **Protocol**
- **定义**：定义结构化的接口
- **语法**：`class Drawable(Protocol): def draw(self): ...`
- **用途**：不需要继承就能"实现"接口
- 依赖：结构化类型
- 后续：runtime_checkable

### [ ] **runtime_checkable**
- **定义**：让 Protocol 支持运行时的 `isinstance()` 检查
- **语法**：`@runtime_checkable` 装饰器
- 依赖：Protocol
- 后续：运行时类型检查

### 6.3 精确类型

### [ ] **字面量类型（Literal）**
- **定义**：表示"精确等于某个值"的类型
- **语法**：`Literal[42]`, `Literal["red", "green", "blue"]`
- **用途**：表达枚举值、配置选项
- 依赖：类型
- 后续：重载、模式匹配

### [ ] **Final**
- **定义**：表示不可被重写/重新赋值的类型
- **用途**：常量、不可重写的方法
- 依赖：类型
- 后续：类型安全

### 6.4 高级类型特性（Python 部分支持或不支持）

### [ ] **依赖类型（Dependent Types）**
- **定义**：类型可以依赖于值
- **例子**：`Array[n]` 表示长度为 n 的数组
- **Python 支持**：❌ 不支持（只能通过 Literal 部分模拟）
- 依赖：类型
- 后续：类型系统的边界

### [ ] **高阶类型（Higher-Kinded Types）**
- **定义**：类型构造器的类型构造器
- **例子**：`F[_]` 表示任意一元类型构造器
- **Python 支持**：❌ 不支持
- 依赖：类型构造器
- 后续：函数式编程、范畴论

### [ ] **线性类型（Linear Types）**
- **定义**：资源必须恰好使用一次
- **用途**：防止资源泄漏（文件句柄、锁）
- **Python 支持**：❌ 不支持
- 依赖：类型
- 后续：资源管理

---

## 第 7 层：保证层 - 类型系统的能力边界

> **核心问题**：类型系统能保证什么？不能保证什么？

### [ ] **类型安全（Type Safety）**
- **定义**：类型检查通过 → 运行时不会类型错误
- **强保证（Sound）**：Rust、Haskell
- **弱保证（Unsound）**：Python、TypeScript
- **Python 现状**：不保证类型安全（可以用 Any、cast 绕过）
- 依赖：类型系统
- 后续：渐进类型

### [ ] **渐进类型（Gradual Typing）**
- **定义**：允许混合使用静态类型和动态类型
- **特点**：可以逐步添加类型提示
- **Python 采用**：PEP 484 的核心设计
- 依赖：类型安全
- 后续：Any

### [ ] **Any**
- **定义**：逃生舱，表示"任何类型"
- **行为**：跳过类型检查
- **用途**：处理无法标注的情况
- **代价**：失去类型安全保证
- 依赖：渐进类型
- 后续：类型安全的边界

### [ ] **完备性 vs 可判定性**
- **完备性**：所有正确的程序都能通过类型检查
- **可判定性**：类型检查能在有限时间内完成
- **哥德尔定理**：不可兼得（需要权衡）
- 依赖：类型系统
- 后续：类型系统的理论限制

### [ ] **Python 类型系统的边界**
- **能做**：基本类型、泛型、联合、Protocol、字面量
- **不能做**：依赖类型、高阶类型、线性类型、完全安全
- **设计哲学**：实用性优先，不追求理论完美
- 依赖：类型系统
- 后续：实践中的权衡

---

## 📚 相关文档

- `typing.md` - Python typing 模块的具体工具清单
- `collections.md` - Python 数据结构（计划中）
- `faq.md` - 常见问题解答

---

## 🎯 学习建议

### 推荐学习顺序

1. **第 1 层 + 第 2 层**：理解"类型是什么"和"子类型"（基础）
2. **第 3 层**：学习 TypeVar 和泛型（实践核心）
3. **第 4 层**：深入型变（最难但最重要）
4. **第 5 层**：类型推导和窄化（实用技巧）
5. **第 6 层**：按需学习高级特性
6. **第 7 层**：理解类型系统的限制（宏观认知）

### 关键里程碑

- ✅ **已掌握**：类型、值、TypeVar（无约束）
- 🎯 **当前目标**：子类型、类型构造器
- 📍 **核心难点**：型变（协变/逆变/不变）
- 🏔️ **终极目标**：能设计类型安全的泛型接口

---

## 💡 核心心理模型

```
                类型系统的本质
                     ↓
            【分类 + 约束 + 检查】
                     ↓
        ┌────────────┼────────────┐
        ↓            ↓            ↓
    类型是什么    类型的关系    构造新类型
    (集合+操作)   (子类型)     (泛型)
                     ↓
              型变（核心难点）
                     ↓
        "类型参数的子类型关系"
         如何影响"构造类型"
                     ↓
        ┌─────┬──────┼──────┬─────┐
        ↓     ↓      ↓      ↓     ↓
      协变  逆变   不变   推导  高级特性
    (输出) (输入) (读写)
```

**记忆口诀**：
- **子类型**是基础（理解"大小"）
- **型变**是核心（理解"关系传递"）
- **协变**看输出（生产者，上界）
- **逆变**看输入（消费者，下界）
- **不变**能读写（大多数容器）

